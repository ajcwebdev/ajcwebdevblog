<h1>Introduction</h1>
<h3>RedwoodJS</h3>
<p><a href="https://redwoodjs.com/">RedwoodJS</a> is an opinionated, full-stack, serverless web application framework for building and deploying JAMstack applications. It was created by Tom-Preston Werner and combines a variety of technologies and techniques that have been influencing the industry over the last 5-10 years. This includes:</p>
<ul>
<li>React frontend</li>
<li>Statically delivered files served from a CDN</li>
<li>GraphQL to connect your frontend and backend</li>
<li>AWS Lambdas for serverless deployment</li>
<li>Deployable with a single git push command</li>
</ul>
<blockquote>
<p><em>My dream of a future is for something I call a universal deployment machine, which means I write my code. It's all text, I just write text. Then I commit to GitHub. Then it's picked up and it's deployed into reality. That's it, that's the whole thing.</em></p>
<p><em><strong>Tom Preston Warner</strong></em>
<em><strong><a href="https://shoptalkshow.com/412/">RedwoodJS Shoptalk (May 11, 2020)</a></strong></em></p>
</blockquote>
<h3>FaunaDB</h3>
<p><a href="https://dashboard.fauna.com/accounts/register?utm_source=DevTo&amp;utm_medium=referral&amp;utm_campaign=WritewithFauna_RedwoodJS_ACampolo">FaunaDB</a> is a serverless global database designed for low latency and developer productivity. It has proven to be particularly appealing to Jamstack developers for its global scalability, native GraphQL API, and FQL query language.</p>
<blockquote>
<p><em>Being a serverless distributed database, the JAMstack world is a natural fit for our system, but long before we were chasing JAMstack developers, we were using the stack ourselves.</em></p>
<p><em><strong>Matt Attaway</strong></em>
<em><strong><a href="https://fauna.com/blog/lessons-learned-livin-la-vida-jamstack">Lessons Learned Livin' La Vida JAMstack (January 24, 2020)</a></strong></em></p>
</blockquote>
<p>In this post, we will walk through how to create an application with RedwoodJS and FaunaDB.</p>
<h1>Redwood Monorepo</h1>
<h3>Create Redwood App</h3>
<p>To start we'll create a new Redwood app from scratch with the Redwood CLI. If you don't have yarn installed enter the following command:</p>
<pre><code>brew install yarn
</code></pre>
<p>Now we'll use <code>yarn create redwood-app</code> to generate the basic structure of our app.</p>
<pre><code>yarn create redwood-app ./redwood-fauna
</code></pre>
<p>I've called my project <code>redwood-fauna</code> but feel free to select whatever name you want for your application. We'll now <code>cd</code> into our new project and use <code>yarn rw dev</code> to start our development server.</p>
<pre><code>cd redwood-fauna
yarn rw dev
</code></pre>
<p>Our project's frontend is running on <code>localhost:8910</code> and our backend is running on <code>localhost:8911</code> ready to receive GraphQL queries.</p>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/i/1r9g4fam6m776cegi050.jpg" alt="01-redwood-starter-page"></p>
<h3>Redwood Directory Structure</h3>
<p>One of Redwood's guiding philosophies is that there is power in standards, so it makes decisions for you about which technologies to use, how to organize your code into files, and how to name things.</p>
<p>It can be a little overwhelming to look at everything that's already been generated for us. The first thing to pay attention to is that Redwood apps are separated into two directories:</p>
<ul>
<li><code>api</code> for backend</li>
<li><code>web</code> for frontend</li>
</ul>
<pre><code>├── api
│   ├── prisma
│   │   ├── schema.prisma
│   │   └── seeds.js
│   └── src
│       ├── functions
│       │   └── graphql.js
│       ├── graphql
│       ├── lib
│       │   └── db.js
│       └── services
└── web
    ├── public
    │   ├── favicon.png
    │   ├── README.md
    │   └── robots.txt
    └── src
        ├── components
        ├── layouts
        ├── pages
            ├── FatalErrorPage
            │   └── FatalErrorPage.js
            └── NotFoundPage
                └── NotFoundPage.js
        ├── index.css
        ├── index.html
        ├── index.js
        └── Routes.js
</code></pre>
<p>Each side has their own path in the codebase. These are managed by Yarn <a href="https://classic.yarnpkg.com/en/docs/workspaces/">workspaces</a>. We will be talking to the Fauna client directly so we can delete the <code>prisma</code> directory along with the files inside it and we can delete all the code in <code>db.js</code>.</p>
<h3>Pages</h3>
<p>With our application now set up we can start creating pages. We'll use the <code>generate page</code> command to create a home page and a folder to hold that page. Instead of <code>generate</code> we can use <code>g</code> to save some typing.</p>
<pre><code>yarn rw g page home /
</code></pre>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/i/thsmbc0k01fy2kkqifez.jpg" alt="02-generated-HomePage"></p>
<p>If we go to our <code>web/src/pages</code> directory we'll see a <code>HomePage</code> directory containing this <code>HomePage.js</code> file:</p>
<pre><code class="language-javascript">// web/src/pages/HomePage/HomePage.js

import { Link } from '@redwoodjs/router'

const HomePage = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;HomePage&lt;/h1&gt;
      &lt;p&gt;Find me in &quot;./web/src/pages/HomePage/HomePage.js&quot;&lt;/p&gt;
      &lt;p&gt;
        My default route is named &quot;home&quot;, link to me with `
        &lt;Link to=&quot;home&quot;&gt;routes.home()&lt;/Link&gt;`
      &lt;/p&gt;
    &lt;/&gt;
  )
}

export default HomePage
</code></pre>
<p>Let's clean up our component. We'll only have a single route for now so we can delete the <code>Link</code> import and <code>routes.home()</code>, and we'll delete everything except a single <code>&lt;h1&gt;</code> tag.</p>
<pre><code class="language-javascript">// web/src/pages/HomePage/HomePage.js

const HomePage = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;RedwoodJS+Fauna&lt;/h1&gt;
    &lt;/&gt;
  )
}

export default HomePage
</code></pre>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/i/xonoxk1scqkms8wazyvo.jpg" alt="03-new-HomePage"></p>
<h3>Cells</h3>
<p>Cells provide a simpler and more declarative approach to data fetching. They contain the GraphQL query, loading, empty, error, and success states, each one rendering itself automatically depending on what state your cell is in.</p>
<p>Create a folder in <code>web/src/components</code> called <code>PostsCell</code> and inside that folder create a file called <code>PostsCell.js</code> with the following code:</p>
<pre><code class="language-javascript">// web/src/components/PostsCell/PostsCell.js

export const QUERY = gql`
  query POSTS {
    posts {
      data {
        title
      }
    }
  }
`

export const Loading = () =&gt; &lt;div&gt;Loading posts...&lt;/div&gt;
export const Empty = () =&gt; &lt;div&gt;No posts yet!&lt;/div&gt;
export const Failure = ({ error }) =&gt; &lt;div&gt;Error: {error.message}&lt;/div&gt;

export const Success = ({ posts }) =&gt; {
  const {data} = posts
  return (
    &lt;ul&gt;
      {data.map(post =&gt; (
        &lt;li&gt;{post.title}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  )
}
</code></pre>
<p>We’re exporting a GraphQL query that will fetch the posts in the database. We use object destructuring to access the data object and then we map over that response data to display a list of our posts. To render our list of posts we need to import <code>PostsCell</code> in our <code>HomePage.js</code> file and return the component.</p>
<pre><code class="language-javascript">// web/src/pages/HomePage/HomePage.js

import PostsCell from 'src/components/PostsCell'

const HomePage = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;RedwoodJS+Fauna&lt;/h1&gt;
      &lt;PostsCell /&gt;
    &lt;/&gt;
  )
}

export default HomePage
</code></pre>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/i/5rrw7dxffhp3qsu37d7k.jpg" alt="04-PostsCell-no-posts"></p>
<h3>Schema Definition Language</h3>
<p>In our <code>graphql</code> directory we'll create a file called <code>posts.sdl.js</code> containing our GraphQL schema. In this file we'll export a schema object containing our GraphQL schema definition language. It is defining a <code>Post</code> type which has a <code>title</code> that is the type of <code>String</code>.</p>
<p>Fauna automatically creates a <code>PostPage</code> type for pagination which has a data type that'll contain an array with every <code>Post</code>. When we create our database you will need to import this schema so Fauna knows how to respond to our GraphQL queries.</p>
<pre><code class="language-javascript">// api/src/graphql/posts.sdl.js

import gql from 'graphql-tag'

export const schema = gql`
  type Post {
    title: String
  }

  type PostPage {
    data: [Post]
  }

  type Query {
    posts: PostPage
  }
`
</code></pre>
<h3>DB</h3>
<p>When we generated our project, <code>db</code> defaulted to an instance of <code>PrismaClient</code>. Since Prisma does not support Fauna at this time we will be using the <code>graphql-request</code> library to query Fauna's GraphQL API. First make sure to add the library to your project.</p>
<pre><code>yarn add graphql-request graphql
</code></pre>
<p>To access our FaunaDB database through the GraphQL endpoint we’ll need to set a request header containing our database key. We’ll see how to create our database key later in this tutorial.</p>
<pre><code class="language-javascript">// api/src/lib/db.js

import { GraphQLClient } from 'graphql-request'

export const request = async (query = {}) =&gt; {
  const endpoint = 'https://graphql.fauna.com/graphql'

  const graphQLClient = new GraphQLClient(endpoint, {
    headers: {
      authorization: 'Bearer &lt;FAUNADB_KEY&gt;'
    },
  })
  try {
    return await graphQLClient.request(query)
  } catch (error) {
    console.log(error)
    return error
  }
}
</code></pre>
<h3>Services</h3>
<p>In our services directory we'll create a posts directory with a file called <code>posts.js</code>. Services are where Redwood centralizes all business logic. These can be used by your GraphQL API or any other place in your backend code. The posts function is querying the Fauna GraphQL endpoint and returning our posts data so it can be consumed by our <code>PostsCell</code>.</p>
<pre><code class="language-javascript">// api/src/services/posts/posts.js

import { request } from 'src/lib/db'
import { gql } from 'graphql-request'

export const posts = async () =&gt; {
  const query = gql`
  {
    posts {
      data {
        title
      }
    }
  }
  `

  const data = await request(query, 'https://graphql.fauna.com/graphql')

  return data['posts']
}
</code></pre>
<h3>GraphQL Serverless Function</h3>
<p>Files in <code>api/src/functions</code> are serverless functions. Most of <code>@redwoodjs/api</code> is for setting up the GraphQL API Redwood Apps come with by default. It happens in essentially four steps:</p>
<ol>
<li>Everything (i.e. sdl and <code>services</code>) is imported</li>
<li>The <code>services</code> are wrapped into resolvers</li>
<li>The sdl and resolvers are merged/stitched into a <code>schema</code></li>
<li>The <code>ApolloServer</code> is instantiated with said merged/stitched <code>schema</code> and <code>context</code></li>
</ol>
<pre><code class="language-javascript">// api/src/functions/graphql.js

import {
  createGraphQLHandler,
  makeMergedSchema,
  makeServices,
} from '@redwoodjs/api'

import schemas from 'src/graphql/**/*.{js,ts}'
import services from 'src/services/**/*.{js,ts}'

import { db } from 'src/lib/db'

export const handler = createGraphQLHandler({
  schema: makeMergedSchema({
    schemas,
    services: makeServices({ services }),
  }),
  db,
})
</code></pre>
<p>Let's take one more look at our entire directory structure before moving on to the Fauna Shell.</p>
<pre><code>├── api
│   └── src
│       ├── functions
│       │   └── graphql.js
│       ├── graphql
│       │   └── posts.sdl.js
│       ├── lib
│       │   └── db.js
│       └── services
│           └── posts
│               └── posts.js
└── web
    ├── public
    │   ├── favicon.png
    │   ├── README.md
    │   └── robots.txt
    └── src
        ├── components
        │   └── PostsCell
        │       └── PostsCell.js
        ├── layouts
        ├── pages
            ├── FatalErrorPage
            ├── HomePage
            │   └── HomePage.js
            └── NotFoundPage
        ├── index.css
        ├── index.html
        ├── index.js
        └── Routes.js
</code></pre>
<h1>Fauna Database</h1>
<h3>Create FaunaDB account</h3>
<p>You'll need a <a href="https://dashboard.fauna.com/accounts/register?utm_source=DevTo&amp;utm_medium=referral&amp;utm_campaign=WritewithFauna_RedwoodJS_ACampolo">FaunaDB</a> account to follow along but it's free for creating simple low traffic databases. You can use your email to create an account or you can use your Github or Netlify account. FaunaDB Shell does not currently support GitHub or Netlify logins so using those will add a couple extra steps when we want to authenticate with the fauna-shell.</p>
<p>First we will install the fauna-shell which will let us easily work with our database from the terminal. You can also go to your dashboard and use Fauna's Web Shell.</p>
<pre><code>npm install -g fauna-shell
</code></pre>
<p>Now we'll login to our Fauna account so we can access a database with the shell.</p>
<pre><code>fauna cloud-login
</code></pre>
<p>You'll be asked to verify your email and password. If you signed up for FaunaDB using your GitHub or Netlify credentials, follow <a href="https://docs.fauna.com/fauna/current/start/cloud-github">these steps</a>, then skip the Create New Database section and continue this tutorial at the beginning of the Collections section.</p>
<h3>Create New Database</h3>
<p>To create your database enter the <code>fauna create-database</code> command and give your database a name.</p>
<pre><code>fauna create-database my_db
</code></pre>
<p>To start the fauna shell with our new database we'll enter the <code>fauna shell</code> command followed by the name of the database.</p>
<pre><code>fauna shell my_db
</code></pre>
<h3>Import Schema</h3>
<p>Save the following code into a file called sdl.gql and import it to your database:</p>
<pre><code class="language-gql">type Post {
  title: String
}
type Query {
  posts: [Post]
}
</code></pre>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/i/dljgy4s4wgu8zdxnt03x.jpg" alt="Alt Text"></p>
<h3>Collections</h3>
<p>To test out our database we'll create a collection with the name Post. A database’s schema is defined by its collections, which are similar to tables in other databases. After entering the command fauna shell will respond with the newly created <code>Collection</code>.</p>
<pre><code class="language-javascript">CreateCollection({ name: &quot;Post&quot; })
</code></pre>
<pre><code class="language-javascript">{
  ref: Collection(&quot;Post&quot;),
  ts: 1597718505570000,
  history_days: 30,
  name: 'Post'
}
</code></pre>
<h3>Create</h3>
<p>The <code>Create</code> function adds a new document to a collection. Let's create our first blog post:</p>
<pre><code class="language-javascript">Create(
  Collection(&quot;Post&quot;),
  {
    data: {
      title: &quot;Deno is a secure runtime for JavaScript and TypeScript&quot;
    }
  }
)
</code></pre>
<pre><code class="language-javascript">{
  ref: Ref(Collection(&quot;Post&quot;), &quot;274160525025214989&quot;),
  ts: 1597718701303000,
  data: {
    title: &quot;Deno is a secure runtime for JavaScript and TypeScript&quot;
  }
}
</code></pre>
<h3>Map</h3>
<p>We can create multiple blog posts with the <code>Map</code> function. We are calling <code>Map</code> with an array of posts and a <code>Lambda</code> that takes <code>post_title</code> as its only parameter. <code>post_title</code> is then used inside the <code>Lambda</code> to provide the title field for each new post.</p>
<pre><code class="language-javascript">Map(
  [
    &quot;Vue.js is an open-source model–view–viewmodel JavaScript framework for building user interfaces and single-page applications&quot;,
    &quot;NextJS is a React framework for building production grade applications that scale&quot;
  ],
  Lambda(&quot;post_title&quot;,
    Create(
      Collection(&quot;Post&quot;),
      {
        data: {
          title: Var(&quot;post_title&quot;)
        }
      }
    )
  )
)
</code></pre>
<pre><code class="language-javascript">[
  {
    ref: Ref(Collection(&quot;Post&quot;), &quot;274160642247624200&quot;),
    ts: 1597718813080000,
    data: {
      title:
        &quot;Vue.js is an open-source model–view–viewmodel JavaScript framework for building user interfaces and single-page applications&quot;
    }
  },
  {
    ref: Ref(Collection(&quot;Post&quot;), &quot;274160642247623176&quot;),
    ts: 1597718813080000,
    data: {
      title:
        &quot;NextJS is a React framework for building production grade applications that scale&quot;
    }
  }
]
</code></pre>
<h3>Get</h3>
<p>The <code>Get</code> function retrieves a single document identified by ref. We can query for a specific post by using its ID.</p>
<pre><code class="language-javascript">Get(
  Ref(
    Collection(&quot;Post&quot;), &quot;274160642247623176&quot;
  )
)
</code></pre>
<pre><code class="language-javascript">{
  ref: Ref(Collection(&quot;Post&quot;), &quot;274160642247623176&quot;),
  ts: 1597718813080000,
  data: {
    title:
      &quot;NextJS is a React framework for building production grade applications that scale&quot;
  }
}
</code></pre>
<h3>Indexes</h3>
<p>Now we'll create an index for retrieving all the posts in our collection.</p>
<pre><code class="language-javascript">CreateIndex({
  name: &quot;posts&quot;,
  source: Collection(&quot;Post&quot;)
})
</code></pre>
<pre><code class="language-javascript">{
  ref: Index(&quot;posts&quot;),
  ts: 1597719006320000,
  active: true,
  serialized: true,
  name: &quot;posts&quot;,
  source: Collection(&quot;Post&quot;),
  partitions: 8
}
</code></pre>
<h3>Match</h3>
<p><code>Index</code> returns a reference to an index which <code>Match</code> accepts and uses to construct a set. <code>Paginate</code> takes the output from <code>Match</code> and returns a <code>Page</code> of results fetched from Fauna. Here we are returning an array of references.</p>
<pre><code class="language-javascript">Paginate(
  Match(
    Index(&quot;posts&quot;)
  )
)
</code></pre>
<pre><code class="language-javascript">{
  data: [
    Ref(Collection(&quot;Post&quot;), &quot;274160525025214989&quot;),
    Ref(Collection(&quot;Post&quot;), &quot;274160642247623176&quot;),
    Ref(Collection(&quot;Post&quot;), &quot;274160642247624200&quot;)
  ]
}
</code></pre>
<h3>Lambda</h3>
<p>We can get an array of references to our posts, but what if we wanted an array of the actual data contained in the reference? We can <code>Map</code> over the array just like we would in any other programming language.</p>
<pre><code class="language-javascript">Map(
  Paginate(
    Match(
      Index(&quot;posts&quot;)
    )
  ),
  Lambda(
    'postRef', Get(Var('postRef'))
  )
)
</code></pre>
<pre><code class="language-javascript">{
  data: [
    {
      ref: Ref(Collection(&quot;Post&quot;), &quot;274160525025214989&quot;),
      ts: 1597718701303000,
      data: {
        title: &quot;Deno is a secure runtime for JavaScript and TypeScript&quot;
      }
    },
    {
      ref: Ref(Collection(&quot;Post&quot;), &quot;274160642247623176&quot;),
      ts: 1597718813080000,
      data: {
        title:
          &quot;NextJS is a React framework for building production grade applications that scale&quot;
      }
    },
    {
      ref: Ref(Collection(&quot;Post&quot;), &quot;274160642247624200&quot;),
      ts: 1597718813080000,
      data: {
        title:
          &quot;Vue.js is an open-source model–view–viewmodel JavaScript framework for building user interfaces and single-page applications&quot;
      }
    }
  ]
}
</code></pre>
<p>So at this point we have our Redwood app set up with just a single:</p>
<ul>
<li><strong>Page</strong> - <code>HomePage.js</code></li>
<li><strong>Cell</strong> - <code>PostsCell.js</code></li>
<li><strong>Function</strong> - <code>graphql.js</code></li>
<li><strong>SDL</strong> - <code>posts.sdl.js</code></li>
<li><strong>Lib</strong> - <code>db.js</code></li>
<li><strong>Service</strong> - <code>posts.js</code></li>
</ul>
<p>We used FQL functions in the Fauna Shell to create a database and seed it with data. FQL functions included:</p>
<ul>
<li><strong>CreateCollection</strong> - Create a collection</li>
<li><strong>Create</strong> - Create a document in a collection</li>
<li><strong>Map</strong> - Applies a function to all array items</li>
<li><strong>Lambda</strong> - Executes an anonymous function</li>
<li><strong>Get</strong> - Retrieves the document for the specified reference</li>
<li><strong>CreateIndex</strong> - Create an index</li>
<li><strong>Match</strong> - Returns the set of items that match search terms</li>
<li><strong>Paginate</strong> - Takes a Set or Ref, and returns a page of results</li>
</ul>
<p>If we return to the home page we'll see our <code>PostsCell</code> is fetching the list of posts from our database.</p>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/i/5acgksshp3pm7pjelvjo.jpg" alt="Alt Text"></p>
<p>And we can also go to our GraphiQL playground on <code>localhost:8911/graphql</code>.</p>
<p><img src="https://dev-to-uploads.s3.amazonaws.com/i/mgzvfzsi2trni7hmpevh.jpg" alt="Alt Text"></p>
<p>RedwoodJS is querying the <a href="https://dashboard.fauna.com/accounts/register?utm_source=DevTo&amp;utm_medium=referral&amp;utm_campaign=WritewithFauna_RedwoodJS_ACampolo">FaunaDB</a> GraphQL API with our posts service on the backend and fetching that data with our PostsCell on the frontend. If we wanted to extend this further we could add mutations to our schema definition language and implement full CRUD capabilities through our GraphQL client.</p>
<p>If you want to learn more about RedwoodJS you can check out the <a href="https://redwoodjs.com/docs/introduction">documentation</a> or visit the RedwoodJS <a href="https://community.redwoodjs.com/">community forum</a>. We would love to see what you’re building and we’re happy to answer any questions you have!</p>
