<p><em>Flux and React are both all about keeping a simple mental model.<br>
-Jing Chen (July 25, 2014)</em></p>
<p>Flux is an application architecture that Facebook uses for building client-side web applications. It complements React's composable view components by utilizing a unidirectional data flow. It is not a framework or a library, but a design pattern inspired by CQRS. It was first debuted at F8 in May 2014 by Jing Chen, Pete Hunt, and Tom Occhino. Jing Chen started her presentation by describing issues cause by scaling an MVC application.</p>
<p><em>MVC works pretty well for small applications. Everything has its own particular role to play. The problem is that it doesn't make room for new features. Let's look at what happens when we add a lot of models and we add a lot of views to the system. There's just an explosion of arrows.<br>
-Jing Chen, <a href="https://www.youtube.com/watch?v=nYkdrAPrdcw">Hacker Way: Rethinking Web App Development at Facebook (May 4, 2014)</a></em></p>
<p><img src="https://sedaily-topics.s3.amazonaws.com/topic_images/0_8200405328446236" alt="Image"></p>
<p>She described a recurring bug in the Facebook Chat system. Users would frequently see a red number over their chat icon signifying an unread message, but when they clicked the icon there would not be any new messages. Facebook's engineers would think that they fixed the bug but it would continually reappear due to the fragility of the coupled architecture. Some engineers referred to this as the &quot;Banana vs. Jungle&quot; problem: you ask for a banana but instead you get back a banana, a gorilla holding the banana, and a jungle containing the gorilla. The Facebook engineers had discovered the need for command-query separation.</p>
<p><em>We found that two-way data bindings lead to cascading updates, where changing one data model led to another data model updating, making it very difficult to predict what would change as the result of a single user interaction.
-Bill Fisher, Jing Chen, <a href="https://reactjs.org/blog/2014/05/06/flux.html">Flux: An Application Architecture for React (May 6, 2014)</a></em></p>
<h3>Command Query Responsibility Segregation</h3>
<p>Commandâ€“query separation is a principle stating that every method should either be a <em>command</em> that performs an action, or a <em>query</em> that returns data to the caller, but not both. In other words, asking a question should not change the answer. Command query responsibility segregation (CQRS) applies the CQS principle by using separate Query and Command objects to retrieve and modify data, respectively. CQRS fits well with event-based programming models, see <a href="https://www.softwaredaily.com/topic/javascript">Javascript Topic Page</a> for a description of how JavaScript handles events in the browser.</p>
<h2>Dispatcher, Store, Views</h2>
<p>Flux eschews MVC in favor of a unidirectional data flow as described on the <a href="https://www.softwaredaily.com/topic/reactjs">React Topic Page</a>. When interacting with a <strong>view (React component)</strong> an action is propagated through a central <strong>dispatcher</strong> to <strong>stores</strong> that hold the application's data and business logic. The stores then update all affected views. The stores accept updates and reconcile them as appropriate, rather than depending on something external to update its data in a consistent way. Nothing outside the store has insight into how it manages data for its domain and there are no direct setter methods.</p>
<p>The flux documentation suggests the following diagram should be the primary mental model for Flux. The dispatcher, stores and views are independent nodes with distinct inputs and outputs. Actions are simple objects containing new data and an identifying type property:</p>
<p><img src="https://facebook.github.io/flux/img/overview/flux-simple-f8-diagram-1300w.png" alt="Unidirectional data flow diagram (Action -&gt; Dispatcher -&gt; Store -&gt; View)">
<em>Data in a Flux application flows in a single direction.<br>
-<a href="https://facebook.github.io/flux/docs/in-depth-overview/">Flux Documentation</a></em></p>
<p>The views may cause a new action to be propagated through the system in response to user interactions:</p>
<p><img src="https://sedaily-topics.s3.amazonaws.com/topic_images/0_1861436422799183" alt="Flux diagram of client action"></p>
<h2>Redux</h2>
<p>Redux is a predictable state container for JavaScript apps. It aims to help applications behave consistently and run in different environments (client, server, and native). While Redux was originally created to be used with React it can also be integrated with any other view library.</p>
<h3>Reducers, Actions, Store</h3>
<p>Reducers are pure functions that take in the state and an action as parameters. The action describes how the state will change. The store is a global variable that holds all of your applications state. The store is known as the single source of truth because it is a global variable that holds all the state in the app.</p>
<p>Redux was created by Dan Abramov for a presentation he gave about hot loading. Redux was a secondary concern for him, but his succinct explanation led to many adopting his version of the Flux architecture.</p>
<p><em>Stores are stateful. If you re-execute the store code it's going to get the new initial state. The state is lost, the subscriptions are lost, it's a bummer. But it doesn't have to be this way. As I was thinking more about trying to work around this and to fit Flux into React hot loader workflow I figured out that store in Flux does too many things. It has too much boilerplate. And I'm not talking about the switch statements. The real boilerplate is in concepts, not in syntax.<br>
-Dan Abramov, <a href="https://www.youtube.com/watch?v=xsSnOQynTHs">Live React: Hot Reloading with Time Travel (July 5, 2015)</a></em></p>
<p>Since then Redux has been the dominant state management solution for React application. But in a series of SEDaily interviews with React luminaries, many expressed a need to move beyond Redux. Other options such as MobX and the Context API have started to be used as substitutes for Redux as state management for React applications.</p>
<p><img src="https://sedaily-topics.s3.amazonaws.com/topic_images/0_4744775498652225.jpg" alt="Image"></p>
